<?php
/**
 * @file
 * Main file for the Commerce Stock Reserve module.
 */

/**
 * Implements hook_entity_delete().
 */
function commerce_stock_reserve_entity_delete($entity, $type) {
  // Release reserved stock when a line item is deleted.
  if ($type == 'commerce_line_item') {
    commerce_stock_reserve($entity, TRUE);
  }
  // Delete reserved stock when a product is deleted.
  elseif ($type == 'commerce_product') {
    db_delete('commerce_stock_reserve')
      ->condition('product_id', $entity->product_id)
      ->execute();
  }
}

/**
 * Get the stock amount that has been reserved for a line item.
 *
 * @param object $line_item
 *   The Commerce line item object.
 *
 * @return string|int
 *   The amount that has been reserved.
 */
function commerce_stock_reserve_get_reserved_amount($line_item) {
  // Only act on product line item types.
  if (!in_array($line_item->type, commerce_product_line_item_types())) {
    return 0;
  }
  $amount = db_select('commerce_stock_reserve', 'csr')
    ->fields('csr', array('amount'))
    ->condition('line_item_id', $line_item->line_item_id)
    ->execute()
    ->fetchField();
  return $amount ? $amount : 0;
}

/**
 * Get the stock amount that a user has reserved for a product.
 *
 * @param object $product
 *   The Commerce product object.
 *
 * @return string|int
 *   The amount that has been reserved.
 */
function commerce_stock_reserve_get_user_reserved_amount($product) {
  static $cache;
  if (isset($cache[$product->product_id])) {
    return $cache[$product->product_id];
  }
  $cache[$product->product_id] = 0;
  global $user;
  // Load the current user's cart if it exists.
  $order = commerce_cart_order_load($user->uid);
  if (!$order) {
    $cache[$product->product_id] = 0;
    return 0;
  }
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  // Get all the line item IDs in the user's cart that contain this product.
  $line_item_ids = array();
  foreach ($order_wrapper->commerce_line_items as $line_item_wrapper) {
    if (in_array($line_item_wrapper->getBundle(), commerce_product_line_item_types())
      && $line_item_wrapper->commerce_product->product_id->value() == $product->product_id) {
        $line_item_ids[] = $line_item_wrapper->line_item_id->value();
    }
  }
  if (!count($line_item_ids)) {
    $cache[$product->product_id] = 0;
    return 0;
  }
  // Get the reserved amount for these line item IDs.
  $select = db_select('commerce_stock_reserve', 'csr')
    ->condition('line_item_id', $line_item_ids, 'IN')
    ->condition('product_id', $product->product_id);
  $select->addExpression('SUM(csr.amount)', 'amount');
  $amount = $select->execute()->fetchField();
  $cache[$product->product_id] = $amount ? $amount : 0;
  return $cache[$product->product_id];
}

/**
 * Check that a product is enabled for stock control.
 *
 * @param object $product
 *   The Commerce product object.
 *
 * @return bool
 *   TRUE if the product has stock enabled, FALSE otherwise.
 */
function commerce_stock_reserve_product_is_enabled($product) {
  $enabled = FALSE;
  // Support Commerce Simple Stock (commerce_ss), probably the most common
  // use-case.
  if (module_exists('commerce_ss')) {
    $enabled = $product->product_id
      && commerce_ss_product_type_enabled($product->type)
      && commerce_ss_product_not_disabled_by_override($product);
  }
  // Allow other modules to alter whether the product has stock control.
  drupal_alter('commerce_stock_reserve_product_is_enabled', $enabled, $product);
  return $enabled;
}

/**
 * Check the current stock level for a product.
 *
 * @param object $product
 *   The Commerce product object.
 *
 * @return mixed
 *   The product's stock amount.
 */
function commerce_stock_reserve_get_product_stock($product) {
  $stock = 0;
  // Support Commerce Simple Stock (commerce_ss).
  if (module_exists('commerce_ss') && !empty($product->commerce_stock)) {
    $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
    $stock = $product_wrapper->commerce_stock->value();
  }
  // Allow other modules to alter the returned stock level.
  drupal_alter('commerce_stock_reserve_get_product_stock', $stock, $product);
  return $stock;
}

/**
 * Set the stock level for a product.
 *
 * @param object $product
 *   The Commerce product object.
 * @param mixed $stock
 *   The new stock.
 * @param bool $skip_save
 *   Set this to TRUE to skip saving the product.
 *
 * @return bool
 *   TRUE on success, FALSE on failure.
 */
function commerce_stock_reserve_set_product_stock($product, $stock, $skip_save = FALSE) {
  $success = FALSE;
  // Support Commerce Simple Stock (commerce_ss).
  if (module_exists('commerce_ss') && isset($product->commerce_stock)) {
    $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
    $product_wrapper->commerce_stock->set($stock);
    $success = TRUE;
  }
  // Allow other modules to try setting the product stock.
  $hook = 'commerce_stock_reserve_set_product_stock';
  foreach (module_implements($hook) as $module_name) {
    $function = $module_name . '_' . $hook;
    $result = $function($product, $stock);
    if ($result === FALSE) {
      return FALSE;
    }
  }
  if (!$skip_save && $success) {
    $success = (bool) commerce_product_save($product);
  }
  return $success;
}

/**
 * Reserve stock for a line item.
 *
 * @param object $line_item
 *   The Commerce line item object.
 * @param bool $release
 *   Whether to release stock rather than reserving it (default: FALSE).
 * @param bool $restore_to_product
 *   Whether to restore the stock to the product when it has been released
 *   (default: TRUE). This only has an effect if $release is TRUE.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function commerce_stock_reserve($line_item, $release = FALSE, $restore_to_product = TRUE) {
  // Only act on product line item types.
  if (!in_array($line_item->type, commerce_product_line_item_types()) || empty($line_item->commerce_product)) {
    return FALSE;
  }

  // Get the product from the line item.
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $product = $line_item_wrapper->commerce_product->value();

  // Check that the product is enabled for stock control.
  if (!commerce_stock_reserve_product_is_enabled($product)) {
    return FALSE;
  }

  // Find out how much stock has been reserved for the line item.
  $current_reserved = commerce_stock_reserve_get_reserved_amount($line_item);
  if ($release && !$current_reserved) {
    // There is no stock to release.
    return TRUE;
  }

  // Get the current stock level.
  $current_stock = commerce_stock_reserve_get_product_stock($product);

  // Calculate how much stock should be reserved. If releasing stock, then this
  // will be a negative value.
  $to_reserve = $release ? -$current_reserved : $line_item->quantity;

  // If the stock is already reserved, there is nothing to do.
  if ($to_reserve == $current_reserved) {
    return TRUE;
  }
  // If there isn't enough stock available for what has been requested, then
  // reset the line item's quantity to the maximum available and log a warning.
  elseif ($to_reserve > $current_stock + $current_reserved) {
    $available = $current_stock + $current_reserved;
    $line_item->quantity = $available;
    $line_item_wrapper->save();
    $to_reserve = $available;
    watchdog('commerce_stock_reserve', 'Quantity reset (@requested requested, @available available) for line item @line_item in order @order (product @sku)', array(
      '@requested' => $to_reserve,
      '@available' => $available,
      '@line_item' => $line_item->line_item_id,
      '@order' => $line_item->order_id,
      '@sku' => $product->sku,
    ), WATCHDOG_WARNING);
  }

  // Calculate the new stock values.
  $new_stock = $current_stock - $to_reserve;
  if (!$release) {
    $new_stock += $current_reserved;
  }

  // Save the product's new stock value and update the reserved stock.
  $transaction = db_transaction(__FUNCTION__);
  if (!$release || $restore_to_product) {
    $update = commerce_stock_reserve_set_product_stock($product, $new_stock);
    if (!$update) {
      throw new Exception('Failed to set stock for product ' . $product->sku);
    }
  }
  if ($to_reserve > 0) {
    $key = array(
      'line_item_id' => $line_item->line_item_id,
      'product_id' => $product->product_id,
    );
    db_merge('commerce_stock_reserve')
      ->key($key)
      ->insertFields($key + array('created' => REQUEST_TIME))
      ->fields(array(
        'amount' => $to_reserve,
        'changed' => REQUEST_TIME,
      ))
      ->execute();
  }
  else {
    // If the reserved stock level is now 0, delete the rows.
    db_delete('commerce_stock_reserve')
      ->condition('line_item_id', $line_item->line_item_id)
      ->execute();
  }
  return TRUE;
}
